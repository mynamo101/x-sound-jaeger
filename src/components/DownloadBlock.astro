---
interface Props {
  downloadUrl: string;
  title?: string;
  description?: string;
  fileSize?: string;
  requiresMembership?: boolean;
  require_tier?: 0 | 1 | 2 | 3;
}

const {
  downloadUrl,
  title = "Download File",
  description,
  fileSize,
  requiresMembership = false,
  require_tier = 0
} = Astro.props;

const tierNameMap = [
  'Free',
  'Support',
  "Creator's Choice",
  'Hero'
];
const getTierLabel = (tier: number) => tierNameMap[tier] || 'Unknown Tier';
const getTierString = (tier: number) => tierNameMap[tier] || 'Support';

const getFileInfo = (url: string) => {
  const fileName = url.split('/').pop() || 'unknown';
  const fileExtension = fileName.split('.').pop()?.toLowerCase() || '';
  const formatInfo = {
    'wav': { format: 'WAV', color: '#ff6b35' },
    'mp3': { format: 'MP3', color: '#4CAF50' },
    'flac': { format: 'FLAC', color: '#2196F3' },
    'aiff': { format: 'AIFF', color: '#9C27B0' },
    'ogg': { format: 'OGG', color: '#FF9800' },
    'm4a': { format: 'M4A', color: '#795548' },
    'aac': { format: 'AAC', color: '#607D8B' },
    'zip': { format: 'ZIP', color: '#607D8B' },
    'rar': { format: 'RAR', color: '#795548' },
    '7z': { format: '7Z', color: '#9C27B0' }
  };
  const info = formatInfo[fileExtension as keyof typeof formatInfo] || {
    format: fileExtension.toUpperCase(),
    color: '#666'
  };
  return {
    fileName,
    fileFormat: info.format,
    formatColor: info.color,
    fileSize: fileSize || 'Unknown file size'
  };
};
const fileInfo = getFileInfo(downloadUrl);
---

<div class="download-block-flex" data-download-url={downloadUrl} data-requires-membership={requiresMembership} data-require-tier={require_tier}>
  <span class="membership-label-badge {`tier-badge-${require_tier}`}" title={getTierLabel(require_tier)}>{getTierLabel(require_tier)}</span>
  <div class="download-flex-row">
    <div class="file-info-flex">
      <div class="file-title">{title}</div>
      {description && <div class="file-description">{description}</div>}
      <div class="file-badges">
        <span class="badge format-badge" style={`background:${fileInfo.formatColor}`}>{fileInfo.fileFormat}</span>
        <span class="badge size-badge" data-file-size>{fileInfo.fileSize}</span>
        <span class="badge name-badge">{fileInfo.fileName}</span>
      </div>
    </div>
    <div class="file-action-flex">
      <button class="download-btn-flex" data-download-action disabled>Download</button>
    </div>
  </div>
</div>

<script type="module">
  // Define notification system here to ensure it's always available
  class NotificationSystem {
    constructor() {
      this.container = null;
      this.notifications = new Map();
      this.init();
    }

    init() {
      this.container = document.getElementById('notification-container');
      if (!this.container) {
        this.container = document.createElement('div');
        this.container.id = 'notification-container';
        this.container.className = 'notification-container';
        document.body.appendChild(this.container);
      }
      console.log('Notification system initialized');
    }    show(message, type = 'info', options = {}) {
      const {
        title = null,
        duration = 5000,
        persistent = false,
        id = null
      } = options;

      // Use message+type+title as unique key to avoid duplicate notifications
      const contentKey = `${type}::${title || ''}::${message}`;
      // Check if notification with same content already exists
      for (const [nid, notif] of this.notifications.entries()) {
        if (notif && notif.dataset && notif.dataset.contentKey === contentKey) {
          // Already exists, do not show again
          return nid;
        }
      }

      const notificationId = id || Date.now().toString() + Math.random();
      console.log('Creating notification with id:', notificationId, 'duration:', duration);

      if (this.notifications.has(notificationId)) {
        this.remove(notificationId);
      }

      const notification = this.createNotification(message, type, title, notificationId);
      notification.dataset.contentKey = contentKey;
      this.container.appendChild(notification);
      this.notifications.set(notificationId, notification);

      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          notification.classList.add('show');
        });
      });

      if (!persistent && duration > 0) {
        setTimeout(() => {
          this.remove(notificationId);
        }, duration);
      }

      return notificationId;
    }

    createNotification(message, type, title, id) {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.dataset.id = id;

      const content = document.createElement('div');
      content.className = 'notification-content';

      const icon = document.createElement('div');
      icon.className = `notification-icon ${type}`;

      const textContainer = document.createElement('div');
      textContainer.className = 'notification-text';

      if (title) {
        const titleElement = document.createElement('div');
        titleElement.className = 'notification-title';
        titleElement.textContent = title;
        textContainer.appendChild(titleElement);
      }

      const messageElement = document.createElement('div');
      messageElement.className = 'notification-message';
      messageElement.textContent = message;
      textContainer.appendChild(messageElement);      const closeButton = document.createElement('button');
      closeButton.className = 'notification-close';
      closeButton.setAttribute('aria-label', 'Close notification');
      
      // Save reference to current instance
      const self = this;
      closeButton.addEventListener('click', function(e) {
        console.log('Close button clicked for notification id:', id);
        e.preventDefault();
        e.stopPropagation();
        self.remove(id);
      });

      content.appendChild(icon);
      content.appendChild(textContainer);
      notification.appendChild(content);
      notification.appendChild(closeButton);

      return notification;
    }    remove(id) {
      console.log('Attempting to remove notification with id:', id);
      const notification = this.notifications.get(id);
      this.notifications.delete(id); // Remove from map first to avoid sync issues
      console.log('Found notification:', notification);
      if (notification && notification.parentNode) {
        console.log('Adding hide class and starting removal');
        notification.classList.add('hide');
        notification.classList.remove('show');
        setTimeout(() => {
          console.log('Timeout reached, removing from DOM');
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
            console.log('Removed from DOM');
          }
        }, 300);
      } else {
        console.log('Notification not found or has no parent');
      }
    }

    success(message, options = {}) {
      return this.show(message, 'success', options);
    }

    error(message, options = {}) {
      return this.show(message, 'error', options);
    }

    warning(message, options = {}) {
      return this.show(message, 'warning', options);
    }

    info(message, options = {}) {
      return this.show(message, 'info', options);
    }
  }

  // Ensure notification system is globally available
  if (!window.notify) {
    window.notify = new NotificationSystem();
  }
  
  async function fetchFileSize(url) {
    try {
      const response = await fetch(url, { method: 'HEAD' });
      const contentLength = response.headers.get('Content-Length');
      if (contentLength) {
        const bytes = parseInt(contentLength);
        return formatFileSize(bytes);
      }
    } catch {}
    return '';
  }
  function formatFileSize(bytes) {
    if (!bytes) return 'Unknown file size';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }  function getAuthToken() {
    return localStorage.getItem('auth_token');
  }
    // Check user membership tier
  async function checkUserTier() {
    const token = getAuthToken();
    if (!token) return null;
    
    try {
      const response = await fetch('http://localhost:3001/api/user/profile', {
        headers: { 'Authorization': `Bearer ${token}` }
      });
      if (response.ok) {
        const data = await response.json();
        return data.user.tier;
      }
    } catch (error) {
      console.error('Failed to get user info:', error);
    }
    return null;
  }
    // Compare membership tiers
  function compareTiers(userTier, requiredTier) {
    const tierLevels = {
      'Free': 0,
      'Support': 1,
      'Creator\'s Choice': 2,
      'Hero': 3
    };
    return tierLevels[userTier] >= tierLevels[requiredTier];
  }
  
  // Backend verification for download permission (final security check)
  async function verifyDownloadPermission(fileUrl) {
    const token = getAuthToken();
    if (!token) {
      return { allowed: false, message: 'Please log in first' };
    }
    
    try {
      // Extract file name from URL as fileId
      const fileName = fileUrl.split('/').pop();
      console.log('Verifying file permission with backend:', fileName);
      const response = await fetch(`http://localhost:3001/api/check-download-access/${fileName}`, {
        headers: { 'Authorization': `Bearer ${token}` }
      });
      
      console.log('Backend response status:', response.status);
      if (response.ok) {
        return { allowed: true };      } else {
        const data = await response.json();
        console.log('Backend verification failed, returned data:', data);
        
        // Show different messages for different error types
        let message = 'Backend verification failed';
        if (data.error === 'File not found') {
          message = 'File does not exist in the system, please contact the administrator';
        } else if (data.required_tier && data.current_tier) {
          message = `Required tier: ${data.required_tier}, your current tier: ${data.current_tier}`;
        } else {
          message = data.error || 'Permission verification failed';
        }
        
        return { 
          allowed: false, 
          message: message
        };
      }
    } catch (error) {
      console.error('Download permission check failed:', error);
      return { allowed: false, message: 'Permission verification failed, please try again later' };
    }
  }  document.addEventListener('DOMContentLoaded', async () => {
    const blocks = document.querySelectorAll('.download-block-flex');
    
    blocks.forEach(async (block) => {
      const btn = block.querySelector('.download-btn-flex');
      const requiresMembership = block.getAttribute('data-requires-membership') === 'true';
      const requireTier = parseInt(block.getAttribute('data-require-tier'));
      const downloadUrl = block.getAttribute('data-download-url');
      const fileSizeElement = block.querySelector('[data-file-size]');
        // Auto-complete file size
      if (fileSizeElement && fileSizeElement.textContent === 'Unknown file size') {
        const realSize = await fetchFileSize(downloadUrl);
        if (realSize) fileSizeElement.textContent = realSize;
      }      // Set background color based on membership tier
      const tierClasses = ['tier-free', 'tier-support', 'tier-creators', 'tier-hero'];
      block.classList.add(tierClasses[requireTier] || 'tier-free');

      // All files require login check
      const userTier = await checkUserTier();
      let frontendCheckPassed = false;      // Free files (require_tier === 0) - button always enabled
      if (requireTier === 0) {
        frontendCheckPassed = true; // Free file, button always enabled
        btn.title = userTier ? '' : 'Click to download (login required)';
      } else {
        // Paid files: check membership tier
        if (requiresMembership) {
          if (!userTier) {
            frontendCheckPassed = false;
            btn.title = 'Please log in as a member first';
          } else {
            const tierNames = ['Free', 'Support', 'Creator\'s Choice', 'Hero'];
            const requiredTierName = tierNames[requireTier] || 'Support';
            
            if (compareTiers(userTier, requiredTierName)) {
              frontendCheckPassed = true;
            } else {
              frontendCheckPassed = false;
              btn.title = `Required tier: ${requiredTierName}, your current tier: ${userTier}`;
            }
          }
        } else {
          // If membership not required, still need login
          frontendCheckPassed = !!userTier;
          if (!userTier) {
            btn.title = 'Please log in as a member first';
          }
        }
      }

      // Set button state based on frontend check
      if (frontendCheckPassed) {
        btn.disabled = false;
        btn.classList.add('can-download');
        btn.title = '';
      } else {
        btn.disabled = true;
        btn.classList.remove('can-download');
      }      // Click event: special handling for free files, paid files require permission check
      btn.addEventListener('click', async () => {
        // Special handling for free files
        if (requireTier === 0) {
          if (!userTier) {
            // Show notification if not logged in
            if (window.notify) {
              window.notify.warning('Please log in as a member before downloading the file', {
                title: 'Login Required',
                duration: 4000
              });
            } else {
              alert('Please log in as a member before downloading the file');
            }
            return;
          }
          // Logged-in free user, download directly
          console.log('Free file, logged-in user downloads directly');
          window.open(downloadUrl, '_blank');
          return;
        }
        
        // Paid file permission check
        if (!frontendCheckPassed) return;
        
        console.log('Performing backend permission verification...');
        const finalCheck = await verifyDownloadPermission(downloadUrl);
        if (finalCheck.allowed) {
          window.open(downloadUrl, '_blank');
        } else {
          if (window.notify) {
            window.notify.error(finalCheck.message || 'Download permission verification failed', {
              title: 'Download Failed',
              duration: 5000
            });
          } else {
            alert(finalCheck.message || 'Download permission verification failed');
          }
        }
      });
    });
  });
</script>

<style>
.download-block-flex {
  border-radius: 12px;
  padding: 2rem 1.5rem;
  margin: 2rem 0;
  box-shadow: 0 2px 8px rgba(0,0,0,0.12);
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
}

/* 免費等級 - 深灰色 */
.download-block-flex.tier-free {
  background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
  border: 1px solid #333;
}

/* Support 等級 - 藍色漸變 */
.download-block-flex.tier-support {
  background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 50%, #1d4ed8 100%);
  border: 1px solid #2563eb;
  box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
}

/* Creator's Choice 等級 - 紫色漸變 */
.download-block-flex.tier-creators {
  background: linear-gradient(135deg, #581c87 0%, #8b5cf6 50%, #7c3aed 100%);
  border: 1px solid #8b5cf6;
  box-shadow: 0 4px 12px rgba(139, 92, 246, 0.25);
}

/* Hero 等級 - 金色漸變 */
.download-block-flex.tier-hero {
  background: linear-gradient(135deg, #92400e 0%, #f59e0b 30%, #fbbf24 50%, #f59e0b 70%, #d97706 100%);
  border: 1px solid #f59e0b;
  box-shadow: 0 6px 16px rgba(245, 158, 11, 0.3);
}

/* 為最高等級添加發光效果 */
.download-block-flex.tier-hero::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
  animation: shimmer 3s ease-in-out infinite;
  pointer-events: none;
}

@keyframes shimmer {
  0%, 100% { transform: translateX(-100%); }
  50% { transform: translateX(100%); }
}

/* Hover 效果 */
.download-block-flex.tier-support:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(59, 130, 246, 0.3);
}

.download-block-flex.tier-creators:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(139, 92, 246, 0.35);
}

.download-block-flex.tier-hero:hover {
  transform: translateY(-3px);
  box-shadow: 0 8px 20px rgba(245, 158, 11, 0.4);
}

.membership-label {
  color: #fff;
  font-size: 1.2rem;
  font-weight: 600;
  margin-bottom: 1.2rem;
  letter-spacing: 1px;
  text-shadow: 0 1px 2px rgba(0,0,0,0.8);
  position: relative;
}

/* 免費等級標籤 */
.tier-free .membership-label {
  color: #d1d5db;
  text-shadow: 0 1px 2px rgba(0,0,0,0.8);
}

/* Support 等級標籤 */
.tier-support .membership-label {
  color: #dbeafe;
  text-shadow: 0 1px 2px rgba(0,0,0,0.8), 0 0 8px rgba(59, 130, 246, 0.3);
}

/* Creator's Choice 等級標籤 */
.tier-creators .membership-label {
  color: #ede9fe;
  text-shadow: 0 1px 2px rgba(0,0,0,0.8), 0 0 8px rgba(139, 92, 246, 0.3);
}

/* Hero 等級標籤 - 金色效果但保持可讀性 */
.tier-hero .membership-label {
  color: #fef3c7;
  text-shadow: 
    0 1px 2px rgba(0,0,0,0.8),
    0 0 10px rgba(245, 158, 11, 0.5),
    0 0 20px rgba(245, 158, 11, 0.3);
  font-weight: 700;
  animation: gold-glow 2s ease-in-out infinite alternate;
}

@keyframes gold-glow {
  0% { 
    text-shadow: 
      0 1px 2px rgba(0,0,0,0.8),
      0 0 10px rgba(245, 158, 11, 0.5),
      0 0 20px rgba(245, 158, 11, 0.3);
  }
  100% { 
    text-shadow: 
      0 1px 2px rgba(0,0,0,0.8),
      0 0 15px rgba(245, 158, 11, 0.8),
      0 0 30px rgba(245, 158, 11, 0.5);
  }
}
.download-flex-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 2rem;
}
.file-info-flex {
  flex: 1;
  min-width: 0;
}
.file-title {
  color: #fff;
  font-size: 1.1rem;
  font-weight: 600;
  margin-bottom: 0.7rem;
  word-break: break-all;
}
.file-description {
  color: #d1d5db;
  font-size: 0.95rem;
  font-weight: 400;
  margin-bottom: 0.8rem;
  line-height: 1.5;
  opacity: 0.9;
}

/* 根據不同等級調整描述文字顏色 */
.tier-support .file-description {
  color: #bfdbfe;
}
.tier-creators .file-description {
  color: #ddd6fe;
}
.tier-hero .file-description {
  color: #fef3c7;
  opacity: 0.95;
}
.file-badges {
  display: flex;
  gap: 0.7rem;
  flex-wrap: wrap;
}
.badge {
  display: inline-block;
  padding: 0.3rem 0.8rem;
  border-radius: 999px;
  font-size: 0.92rem;
  font-weight: 500;
  color: #fff;
  background: #444;
  letter-spacing: 0.5px;
}
.format-badge {
  text-transform: uppercase;
}
.size-badge {
  background: #666;
}
.name-badge {
  background: #333;
  color: #eee;
  max-width: 180px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.file-action-flex {
  display: flex;
  align-items: center;
  justify-content: flex-end;
}
.download-btn-flex {
  min-width: 120px;
  padding: 0.85rem 1.7rem;
  border-radius: 8px;
  font-size: 1.1rem;
  font-weight: 600;
  border: none;
  background: #555;
  color: #fff;
  cursor: not-allowed;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.download-btn-flex:disabled {
  opacity: 0.7;
}

/* 免費等級按鈕 */
.tier-free .download-btn-flex.can-download {
  background: rgba(70 70 70 / 0.8);
  cursor: pointer;
}

.tier-free .download-btn-flex.can-download:hover {
  background: rgba(224 224 224 / 0.9);
}

/* Support 等級按鈕 */
.tier-support .download-btn-flex.can-download {
  background: linear-gradient(135deg, #1d4ed8 0%, #3b82f6 100%);
  border: 1px solid #2563eb;
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(59, 130, 246, 0.2);
}

.tier-support .download-btn-flex.can-download:hover {
  background: linear-gradient(135deg, #2563eb 0%, #60a5fa 100%);
  transform: translateY(-2px);
  box-shadow: 0 6px 12px rgba(59, 130, 246, 0.3);
}

/* Creator's Choice 等級按鈕 */
.tier-creators .download-btn-flex.can-download {
  background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
  border: 1px solid #8b5cf6;
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(139, 92, 246, 0.2);
}

.tier-creators .download-btn-flex.can-download:hover {
  background: linear-gradient(135deg, #8b5cf6 0%, #a78bfa 100%);
  transform: translateY(-2px);
  box-shadow: 0 6px 12px rgba(139, 92, 246, 0.3);
}

/* Hero 等級按鈕 - 豪華金色 */
.tier-hero .download-btn-flex.can-download {
  background: linear-gradient(135deg, #d97706 0%, #f59e0b 50%, #fbbf24 100%);
  border: 1px solid #f59e0b;
  cursor: pointer;
  box-shadow: 0 4px 8px rgba(245, 158, 11, 0.3);
  font-weight: 700;
}

.tier-hero .download-btn-flex.can-download:hover {
  background: linear-gradient(135deg, #f59e0b 0%, #fbbf24 50%, #fcd34d 100%);
  transform: translateY(-3px);
  box-shadow: 0 8px 16px rgba(245, 158, 11, 0.4);
}

/* 金色按鈕發光效果 */
.tier-hero .download-btn-flex.can-download::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.2) 50%, transparent 70%);
  animation: button-shimmer 2s ease-in-out infinite;
  pointer-events: none;
}

@keyframes button-shimmer {
  0%, 100% { transform: translateX(-100%); }
  50% { transform: translateX(100%); }
}
@media (max-width: 700px) {
  .download-flex-row {
    flex-direction: column;
    align-items: stretch;
    gap: 1.2rem;
  }
  .file-action-flex {
    justify-content: stretch;
  }
}

/* Notification system styles */
.notification-container {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 10000;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.notification {
  background: #ffffff;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  padding: 20px 30px;
  margin-bottom: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  min-width: 300px;
  max-width: 500px;
  pointer-events: auto; /* 這裡要 auto，才能點擊 close */
  transform: translateY(-100px) scale(0.95);
  opacity: 0;
  transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
  position: relative;
  will-change: transform, opacity;
}

.notification-content {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  position: relative;
}

/* 將 close button 放進 notification-content 右上角 */
.notification-close {
  position: absolute;
  top: 0;
  right: 0;
  width: 24px;
  height: 24px;
  border: none;
  background: none;
  cursor: pointer;
  color: #6b7280;
  font-size: 20px;
  line-height: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  transition: background-color 0.2s ease;
  z-index: 2;
}

.notification-close:hover {
  background: #f3f4f6;
}

.notification-close::before {
  content: '×';
}

.notification-icon {
  width: 20px;
  height: 20px;
  flex-shrink: 0;
  margin-top: 2px;
}

.notification-icon.success::before {
  content: '✓';
  color: #10b981;
  font-weight: bold;
  font-size: 24px;
}

.notification-icon.error::before {
  content: '✕';
  color: #ef4444;
  font-weight: bold;
  font-size: 24px;
}

.notification-icon.warning::before {
  content: '⚠';
  color: #f59e0b;
  font-weight: bold;
  font-size: 24px;
}

.notification-icon.info::before {
  content: 'ℹ';
  color: #3b82f6;
  font-weight: bold;
  font-size: 24px;
}

.notification-text {
  flex: 1;
}

.notification-title {
  font-weight: 600;
  font-size: 100%;
  color: #1f2937;
  margin: 0 0 4px 0;
}

.notification-message {
  font-size: 100%;
  color: #4b5563;
  margin: 0;
  line-height: 1.4;
}

/* New styles */
.membership-label-badge {
  position: absolute;
  bottom: 16px;
  right: 16px;
  z-index: 2;
  display: inline-block;
  font-size: 1rem;
  font-weight: 300;
  letter-spacing: 3px;
  color: rgba(255 255 255 / 0.43);
  pointer-events: auto;
}
.tier-badge-0 { background: #444; color: #d1d5db; }
.tier-badge-1 { background: linear-gradient(90deg,#2563eb,#3b82f6); color: #dbeafe; }
.tier-badge-2 { background: linear-gradient(90deg,#7c3aed,#8b5cf6); color: #ede9fe; }
.tier-badge-3 { background: linear-gradient(90deg,#f59e0b,#fbbf24); color: #fef3c7; border: 2px solid #fbbf24; box-shadow: 0 0 12px #fbbf24aa; }

.file-info-flex {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  justify-content: flex-start;
}
.file-title {
  margin-top: 0;
}
</style>